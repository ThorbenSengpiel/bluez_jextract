// Generated by jextract

package bluez.binding;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.VarHandle;
import java.nio.ByteOrder;
import jdk.incubator.foreign.*;
import static jdk.incubator.foreign.ValueLayout.*;
public class _GThreadFunctions {

    static final  GroupLayout $struct$LAYOUT = MemoryLayout.structLayout(
        Constants$root.C_POINTER$LAYOUT.withName("mutex_new"),
        Constants$root.C_POINTER$LAYOUT.withName("mutex_lock"),
        Constants$root.C_POINTER$LAYOUT.withName("mutex_trylock"),
        Constants$root.C_POINTER$LAYOUT.withName("mutex_unlock"),
        Constants$root.C_POINTER$LAYOUT.withName("mutex_free"),
        Constants$root.C_POINTER$LAYOUT.withName("cond_new"),
        Constants$root.C_POINTER$LAYOUT.withName("cond_signal"),
        Constants$root.C_POINTER$LAYOUT.withName("cond_broadcast"),
        Constants$root.C_POINTER$LAYOUT.withName("cond_wait"),
        Constants$root.C_POINTER$LAYOUT.withName("cond_timed_wait"),
        Constants$root.C_POINTER$LAYOUT.withName("cond_free"),
        Constants$root.C_POINTER$LAYOUT.withName("private_new"),
        Constants$root.C_POINTER$LAYOUT.withName("private_get"),
        Constants$root.C_POINTER$LAYOUT.withName("private_set"),
        Constants$root.C_POINTER$LAYOUT.withName("thread_create"),
        Constants$root.C_POINTER$LAYOUT.withName("thread_yield"),
        Constants$root.C_POINTER$LAYOUT.withName("thread_join"),
        Constants$root.C_POINTER$LAYOUT.withName("thread_exit"),
        Constants$root.C_POINTER$LAYOUT.withName("thread_set_priority"),
        Constants$root.C_POINTER$LAYOUT.withName("thread_self"),
        Constants$root.C_POINTER$LAYOUT.withName("thread_equal")
    ).withName("_GThreadFunctions");
    public static MemoryLayout $LAYOUT() {
        return _GThreadFunctions.$struct$LAYOUT;
    }
    static final FunctionDescriptor mutex_new$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT);
    static final MethodHandle mutex_new$MH = RuntimeHelper.downcallHandle(
        _GThreadFunctions.mutex_new$FUNC, false
    );
    public interface mutex_new {

        Addressable apply();
        static NativeSymbol allocate(mutex_new fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(mutex_new.class, fi, _GThreadFunctions.mutex_new$FUNC, "()Ljdk/incubator/foreign/Addressable;", scope);
        }
        static mutex_new ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("mutex_new::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return () -> {
                try {
                    return (Addressable)(MemoryAddress)_GThreadFunctions.mutex_new$MH.invokeExact(symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle mutex_new$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("mutex_new"));
    public static VarHandle mutex_new$VH() {
        return _GThreadFunctions.mutex_new$VH;
    }
    public static MemoryAddress mutex_new$get(MemorySegment seg) {
        return (MemoryAddress)_GThreadFunctions.mutex_new$VH.get(seg);
    }
    public static void mutex_new$set( MemorySegment seg, MemoryAddress x) {
        _GThreadFunctions.mutex_new$VH.set(seg, x);
    }
    public static MemoryAddress mutex_new$get(MemorySegment seg, long index) {
        return (MemoryAddress)_GThreadFunctions.mutex_new$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void mutex_new$set(MemorySegment seg, long index, MemoryAddress x) {
        _GThreadFunctions.mutex_new$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static mutex_new mutex_new (MemorySegment segment, ResourceScope scope) {
        return mutex_new.ofAddress(mutex_new$get(segment), scope);
    }
    static final FunctionDescriptor mutex_lock$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle mutex_lock$MH = RuntimeHelper.downcallHandle(
        _GThreadFunctions.mutex_lock$FUNC, false
    );
    public interface mutex_lock {

        void apply(MemoryAddress _x0);
        static NativeSymbol allocate(mutex_lock fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(mutex_lock.class, fi, _GThreadFunctions.mutex_lock$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)V", scope);
        }
        static mutex_lock ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("mutex_lock::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (MemoryAddress __x0) -> {
                try {
                    _GThreadFunctions.mutex_lock$MH.invokeExact(symbol, (Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle mutex_lock$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("mutex_lock"));
    public static VarHandle mutex_lock$VH() {
        return _GThreadFunctions.mutex_lock$VH;
    }
    public static MemoryAddress mutex_lock$get(MemorySegment seg) {
        return (MemoryAddress)_GThreadFunctions.mutex_lock$VH.get(seg);
    }
    public static void mutex_lock$set( MemorySegment seg, MemoryAddress x) {
        _GThreadFunctions.mutex_lock$VH.set(seg, x);
    }
    public static MemoryAddress mutex_lock$get(MemorySegment seg, long index) {
        return (MemoryAddress)_GThreadFunctions.mutex_lock$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void mutex_lock$set(MemorySegment seg, long index, MemoryAddress x) {
        _GThreadFunctions.mutex_lock$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static mutex_lock mutex_lock (MemorySegment segment, ResourceScope scope) {
        return mutex_lock.ofAddress(mutex_lock$get(segment), scope);
    }
    static final FunctionDescriptor mutex_trylock$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle mutex_trylock$MH = RuntimeHelper.downcallHandle(
        _GThreadFunctions.mutex_trylock$FUNC, false
    );
    public interface mutex_trylock {

        int apply(MemoryAddress _x0);
        static NativeSymbol allocate(mutex_trylock fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(mutex_trylock.class, fi, _GThreadFunctions.mutex_trylock$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static mutex_trylock ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("mutex_trylock::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (MemoryAddress __x0) -> {
                try {
                    return (int)_GThreadFunctions.mutex_trylock$MH.invokeExact(symbol, (Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle mutex_trylock$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("mutex_trylock"));
    public static VarHandle mutex_trylock$VH() {
        return _GThreadFunctions.mutex_trylock$VH;
    }
    public static MemoryAddress mutex_trylock$get(MemorySegment seg) {
        return (MemoryAddress)_GThreadFunctions.mutex_trylock$VH.get(seg);
    }
    public static void mutex_trylock$set( MemorySegment seg, MemoryAddress x) {
        _GThreadFunctions.mutex_trylock$VH.set(seg, x);
    }
    public static MemoryAddress mutex_trylock$get(MemorySegment seg, long index) {
        return (MemoryAddress)_GThreadFunctions.mutex_trylock$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void mutex_trylock$set(MemorySegment seg, long index, MemoryAddress x) {
        _GThreadFunctions.mutex_trylock$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static mutex_trylock mutex_trylock (MemorySegment segment, ResourceScope scope) {
        return mutex_trylock.ofAddress(mutex_trylock$get(segment), scope);
    }
    static final FunctionDescriptor mutex_unlock$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle mutex_unlock$MH = RuntimeHelper.downcallHandle(
        _GThreadFunctions.mutex_unlock$FUNC, false
    );
    public interface mutex_unlock {

        void apply(MemoryAddress _x0);
        static NativeSymbol allocate(mutex_unlock fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(mutex_unlock.class, fi, _GThreadFunctions.mutex_unlock$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)V", scope);
        }
        static mutex_unlock ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("mutex_unlock::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (MemoryAddress __x0) -> {
                try {
                    _GThreadFunctions.mutex_unlock$MH.invokeExact(symbol, (Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle mutex_unlock$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("mutex_unlock"));
    public static VarHandle mutex_unlock$VH() {
        return _GThreadFunctions.mutex_unlock$VH;
    }
    public static MemoryAddress mutex_unlock$get(MemorySegment seg) {
        return (MemoryAddress)_GThreadFunctions.mutex_unlock$VH.get(seg);
    }
    public static void mutex_unlock$set( MemorySegment seg, MemoryAddress x) {
        _GThreadFunctions.mutex_unlock$VH.set(seg, x);
    }
    public static MemoryAddress mutex_unlock$get(MemorySegment seg, long index) {
        return (MemoryAddress)_GThreadFunctions.mutex_unlock$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void mutex_unlock$set(MemorySegment seg, long index, MemoryAddress x) {
        _GThreadFunctions.mutex_unlock$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static mutex_unlock mutex_unlock (MemorySegment segment, ResourceScope scope) {
        return mutex_unlock.ofAddress(mutex_unlock$get(segment), scope);
    }
    static final FunctionDescriptor mutex_free$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle mutex_free$MH = RuntimeHelper.downcallHandle(
        _GThreadFunctions.mutex_free$FUNC, false
    );
    public interface mutex_free {

        void apply(MemoryAddress _x0);
        static NativeSymbol allocate(mutex_free fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(mutex_free.class, fi, _GThreadFunctions.mutex_free$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)V", scope);
        }
        static mutex_free ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("mutex_free::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (MemoryAddress __x0) -> {
                try {
                    _GThreadFunctions.mutex_free$MH.invokeExact(symbol, (Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle mutex_free$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("mutex_free"));
    public static VarHandle mutex_free$VH() {
        return _GThreadFunctions.mutex_free$VH;
    }
    public static MemoryAddress mutex_free$get(MemorySegment seg) {
        return (MemoryAddress)_GThreadFunctions.mutex_free$VH.get(seg);
    }
    public static void mutex_free$set( MemorySegment seg, MemoryAddress x) {
        _GThreadFunctions.mutex_free$VH.set(seg, x);
    }
    public static MemoryAddress mutex_free$get(MemorySegment seg, long index) {
        return (MemoryAddress)_GThreadFunctions.mutex_free$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void mutex_free$set(MemorySegment seg, long index, MemoryAddress x) {
        _GThreadFunctions.mutex_free$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static mutex_free mutex_free (MemorySegment segment, ResourceScope scope) {
        return mutex_free.ofAddress(mutex_free$get(segment), scope);
    }
    static final FunctionDescriptor cond_new$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT);
    static final MethodHandle cond_new$MH = RuntimeHelper.downcallHandle(
        _GThreadFunctions.cond_new$FUNC, false
    );
    public interface cond_new {

        Addressable apply();
        static NativeSymbol allocate(cond_new fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(cond_new.class, fi, _GThreadFunctions.cond_new$FUNC, "()Ljdk/incubator/foreign/Addressable;", scope);
        }
        static cond_new ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("cond_new::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return () -> {
                try {
                    return (Addressable)(MemoryAddress)_GThreadFunctions.cond_new$MH.invokeExact(symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle cond_new$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("cond_new"));
    public static VarHandle cond_new$VH() {
        return _GThreadFunctions.cond_new$VH;
    }
    public static MemoryAddress cond_new$get(MemorySegment seg) {
        return (MemoryAddress)_GThreadFunctions.cond_new$VH.get(seg);
    }
    public static void cond_new$set( MemorySegment seg, MemoryAddress x) {
        _GThreadFunctions.cond_new$VH.set(seg, x);
    }
    public static MemoryAddress cond_new$get(MemorySegment seg, long index) {
        return (MemoryAddress)_GThreadFunctions.cond_new$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void cond_new$set(MemorySegment seg, long index, MemoryAddress x) {
        _GThreadFunctions.cond_new$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static cond_new cond_new (MemorySegment segment, ResourceScope scope) {
        return cond_new.ofAddress(cond_new$get(segment), scope);
    }
    static final FunctionDescriptor cond_signal$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle cond_signal$MH = RuntimeHelper.downcallHandle(
        _GThreadFunctions.cond_signal$FUNC, false
    );
    public interface cond_signal {

        void apply(MemoryAddress _x0);
        static NativeSymbol allocate(cond_signal fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(cond_signal.class, fi, _GThreadFunctions.cond_signal$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)V", scope);
        }
        static cond_signal ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("cond_signal::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (MemoryAddress __x0) -> {
                try {
                    _GThreadFunctions.cond_signal$MH.invokeExact(symbol, (Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle cond_signal$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("cond_signal"));
    public static VarHandle cond_signal$VH() {
        return _GThreadFunctions.cond_signal$VH;
    }
    public static MemoryAddress cond_signal$get(MemorySegment seg) {
        return (MemoryAddress)_GThreadFunctions.cond_signal$VH.get(seg);
    }
    public static void cond_signal$set( MemorySegment seg, MemoryAddress x) {
        _GThreadFunctions.cond_signal$VH.set(seg, x);
    }
    public static MemoryAddress cond_signal$get(MemorySegment seg, long index) {
        return (MemoryAddress)_GThreadFunctions.cond_signal$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void cond_signal$set(MemorySegment seg, long index, MemoryAddress x) {
        _GThreadFunctions.cond_signal$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static cond_signal cond_signal (MemorySegment segment, ResourceScope scope) {
        return cond_signal.ofAddress(cond_signal$get(segment), scope);
    }
    static final FunctionDescriptor cond_broadcast$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle cond_broadcast$MH = RuntimeHelper.downcallHandle(
        _GThreadFunctions.cond_broadcast$FUNC, false
    );
    public interface cond_broadcast {

        void apply(MemoryAddress _x0);
        static NativeSymbol allocate(cond_broadcast fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(cond_broadcast.class, fi, _GThreadFunctions.cond_broadcast$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)V", scope);
        }
        static cond_broadcast ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("cond_broadcast::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (MemoryAddress __x0) -> {
                try {
                    _GThreadFunctions.cond_broadcast$MH.invokeExact(symbol, (Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle cond_broadcast$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("cond_broadcast"));
    public static VarHandle cond_broadcast$VH() {
        return _GThreadFunctions.cond_broadcast$VH;
    }
    public static MemoryAddress cond_broadcast$get(MemorySegment seg) {
        return (MemoryAddress)_GThreadFunctions.cond_broadcast$VH.get(seg);
    }
    public static void cond_broadcast$set( MemorySegment seg, MemoryAddress x) {
        _GThreadFunctions.cond_broadcast$VH.set(seg, x);
    }
    public static MemoryAddress cond_broadcast$get(MemorySegment seg, long index) {
        return (MemoryAddress)_GThreadFunctions.cond_broadcast$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void cond_broadcast$set(MemorySegment seg, long index, MemoryAddress x) {
        _GThreadFunctions.cond_broadcast$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static cond_broadcast cond_broadcast (MemorySegment segment, ResourceScope scope) {
        return cond_broadcast.ofAddress(cond_broadcast$get(segment), scope);
    }
    static final FunctionDescriptor cond_wait$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle cond_wait$MH = RuntimeHelper.downcallHandle(
        _GThreadFunctions.cond_wait$FUNC, false
    );
    public interface cond_wait {

        void apply(MemoryAddress _x0, MemoryAddress _x1);
        static NativeSymbol allocate(cond_wait fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(cond_wait.class, fi, _GThreadFunctions.cond_wait$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)V", scope);
        }
        static cond_wait ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("cond_wait::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (MemoryAddress __x0, MemoryAddress __x1) -> {
                try {
                    _GThreadFunctions.cond_wait$MH.invokeExact(symbol, (Addressable)__x0, (Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle cond_wait$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("cond_wait"));
    public static VarHandle cond_wait$VH() {
        return _GThreadFunctions.cond_wait$VH;
    }
    public static MemoryAddress cond_wait$get(MemorySegment seg) {
        return (MemoryAddress)_GThreadFunctions.cond_wait$VH.get(seg);
    }
    public static void cond_wait$set( MemorySegment seg, MemoryAddress x) {
        _GThreadFunctions.cond_wait$VH.set(seg, x);
    }
    public static MemoryAddress cond_wait$get(MemorySegment seg, long index) {
        return (MemoryAddress)_GThreadFunctions.cond_wait$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void cond_wait$set(MemorySegment seg, long index, MemoryAddress x) {
        _GThreadFunctions.cond_wait$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static cond_wait cond_wait (MemorySegment segment, ResourceScope scope) {
        return cond_wait.ofAddress(cond_wait$get(segment), scope);
    }
    static final FunctionDescriptor cond_timed_wait$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle cond_timed_wait$MH = RuntimeHelper.downcallHandle(
        _GThreadFunctions.cond_timed_wait$FUNC, false
    );
    public interface cond_timed_wait {

        int apply(MemoryAddress _x0, MemoryAddress _x1, MemoryAddress _x2);
        static NativeSymbol allocate(cond_timed_wait fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(cond_timed_wait.class, fi, _GThreadFunctions.cond_timed_wait$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static cond_timed_wait ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("cond_timed_wait::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (MemoryAddress __x0, MemoryAddress __x1, MemoryAddress __x2) -> {
                try {
                    return (int)_GThreadFunctions.cond_timed_wait$MH.invokeExact(symbol, (Addressable)__x0, (Addressable)__x1, (Addressable)__x2);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle cond_timed_wait$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("cond_timed_wait"));
    public static VarHandle cond_timed_wait$VH() {
        return _GThreadFunctions.cond_timed_wait$VH;
    }
    public static MemoryAddress cond_timed_wait$get(MemorySegment seg) {
        return (MemoryAddress)_GThreadFunctions.cond_timed_wait$VH.get(seg);
    }
    public static void cond_timed_wait$set( MemorySegment seg, MemoryAddress x) {
        _GThreadFunctions.cond_timed_wait$VH.set(seg, x);
    }
    public static MemoryAddress cond_timed_wait$get(MemorySegment seg, long index) {
        return (MemoryAddress)_GThreadFunctions.cond_timed_wait$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void cond_timed_wait$set(MemorySegment seg, long index, MemoryAddress x) {
        _GThreadFunctions.cond_timed_wait$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static cond_timed_wait cond_timed_wait (MemorySegment segment, ResourceScope scope) {
        return cond_timed_wait.ofAddress(cond_timed_wait$get(segment), scope);
    }
    static final FunctionDescriptor cond_free$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle cond_free$MH = RuntimeHelper.downcallHandle(
        _GThreadFunctions.cond_free$FUNC, false
    );
    public interface cond_free {

        void apply(MemoryAddress _x0);
        static NativeSymbol allocate(cond_free fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(cond_free.class, fi, _GThreadFunctions.cond_free$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)V", scope);
        }
        static cond_free ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("cond_free::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (MemoryAddress __x0) -> {
                try {
                    _GThreadFunctions.cond_free$MH.invokeExact(symbol, (Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle cond_free$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("cond_free"));
    public static VarHandle cond_free$VH() {
        return _GThreadFunctions.cond_free$VH;
    }
    public static MemoryAddress cond_free$get(MemorySegment seg) {
        return (MemoryAddress)_GThreadFunctions.cond_free$VH.get(seg);
    }
    public static void cond_free$set( MemorySegment seg, MemoryAddress x) {
        _GThreadFunctions.cond_free$VH.set(seg, x);
    }
    public static MemoryAddress cond_free$get(MemorySegment seg, long index) {
        return (MemoryAddress)_GThreadFunctions.cond_free$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void cond_free$set(MemorySegment seg, long index, MemoryAddress x) {
        _GThreadFunctions.cond_free$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static cond_free cond_free (MemorySegment segment, ResourceScope scope) {
        return cond_free.ofAddress(cond_free$get(segment), scope);
    }
    static final FunctionDescriptor private_new$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle private_new$MH = RuntimeHelper.downcallHandle(
        _GThreadFunctions.private_new$FUNC, false
    );
    public interface private_new {

        Addressable apply(MemoryAddress _x0);
        static NativeSymbol allocate(private_new fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(private_new.class, fi, _GThreadFunctions.private_new$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/Addressable;", scope);
        }
        static private_new ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("private_new::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (MemoryAddress __x0) -> {
                try {
                    return (Addressable)(MemoryAddress)_GThreadFunctions.private_new$MH.invokeExact(symbol, (Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle private_new$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("private_new"));
    public static VarHandle private_new$VH() {
        return _GThreadFunctions.private_new$VH;
    }
    public static MemoryAddress private_new$get(MemorySegment seg) {
        return (MemoryAddress)_GThreadFunctions.private_new$VH.get(seg);
    }
    public static void private_new$set( MemorySegment seg, MemoryAddress x) {
        _GThreadFunctions.private_new$VH.set(seg, x);
    }
    public static MemoryAddress private_new$get(MemorySegment seg, long index) {
        return (MemoryAddress)_GThreadFunctions.private_new$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void private_new$set(MemorySegment seg, long index, MemoryAddress x) {
        _GThreadFunctions.private_new$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static private_new private_new (MemorySegment segment, ResourceScope scope) {
        return private_new.ofAddress(private_new$get(segment), scope);
    }
    static final FunctionDescriptor private_get$FUNC = FunctionDescriptor.of(Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle private_get$MH = RuntimeHelper.downcallHandle(
        _GThreadFunctions.private_get$FUNC, false
    );
    public interface private_get {

        Addressable apply(MemoryAddress _x0);
        static NativeSymbol allocate(private_get fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(private_get.class, fi, _GThreadFunctions.private_get$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)Ljdk/incubator/foreign/Addressable;", scope);
        }
        static private_get ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("private_get::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (MemoryAddress __x0) -> {
                try {
                    return (Addressable)(MemoryAddress)_GThreadFunctions.private_get$MH.invokeExact(symbol, (Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle private_get$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("private_get"));
    public static VarHandle private_get$VH() {
        return _GThreadFunctions.private_get$VH;
    }
    public static MemoryAddress private_get$get(MemorySegment seg) {
        return (MemoryAddress)_GThreadFunctions.private_get$VH.get(seg);
    }
    public static void private_get$set( MemorySegment seg, MemoryAddress x) {
        _GThreadFunctions.private_get$VH.set(seg, x);
    }
    public static MemoryAddress private_get$get(MemorySegment seg, long index) {
        return (MemoryAddress)_GThreadFunctions.private_get$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void private_get$set(MemorySegment seg, long index, MemoryAddress x) {
        _GThreadFunctions.private_get$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static private_get private_get (MemorySegment segment, ResourceScope scope) {
        return private_get.ofAddress(private_get$get(segment), scope);
    }
    static final FunctionDescriptor private_set$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle private_set$MH = RuntimeHelper.downcallHandle(
        _GThreadFunctions.private_set$FUNC, false
    );
    public interface private_set {

        void apply(MemoryAddress _x0, MemoryAddress _x1);
        static NativeSymbol allocate(private_set fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(private_set.class, fi, _GThreadFunctions.private_set$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)V", scope);
        }
        static private_set ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("private_set::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (MemoryAddress __x0, MemoryAddress __x1) -> {
                try {
                    _GThreadFunctions.private_set$MH.invokeExact(symbol, (Addressable)__x0, (Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle private_set$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("private_set"));
    public static VarHandle private_set$VH() {
        return _GThreadFunctions.private_set$VH;
    }
    public static MemoryAddress private_set$get(MemorySegment seg) {
        return (MemoryAddress)_GThreadFunctions.private_set$VH.get(seg);
    }
    public static void private_set$set( MemorySegment seg, MemoryAddress x) {
        _GThreadFunctions.private_set$VH.set(seg, x);
    }
    public static MemoryAddress private_set$get(MemorySegment seg, long index) {
        return (MemoryAddress)_GThreadFunctions.private_set$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void private_set$set(MemorySegment seg, long index, MemoryAddress x) {
        _GThreadFunctions.private_set$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static private_set private_set (MemorySegment segment, ResourceScope scope) {
        return private_set.ofAddress(private_set$get(segment), scope);
    }
    static final FunctionDescriptor thread_create$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_LONG_LONG$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle thread_create$MH = RuntimeHelper.downcallHandle(
        _GThreadFunctions.thread_create$FUNC, false
    );
    public interface thread_create {

        void apply(MemoryAddress _x0, MemoryAddress _x1, long _x2, int _x3, int _x4, int _x5, MemoryAddress _x6, MemoryAddress _x7);
        static NativeSymbol allocate(thread_create fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(thread_create.class, fi, _GThreadFunctions.thread_create$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;JIIILjdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)V", scope);
        }
        static thread_create ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("thread_create::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (MemoryAddress __x0, MemoryAddress __x1, long __x2, int __x3, int __x4, int __x5, MemoryAddress __x6, MemoryAddress __x7) -> {
                try {
                    _GThreadFunctions.thread_create$MH.invokeExact(symbol, (Addressable)__x0, (Addressable)__x1, __x2, __x3, __x4, __x5, (Addressable)__x6, (Addressable)__x7);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle thread_create$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("thread_create"));
    public static VarHandle thread_create$VH() {
        return _GThreadFunctions.thread_create$VH;
    }
    public static MemoryAddress thread_create$get(MemorySegment seg) {
        return (MemoryAddress)_GThreadFunctions.thread_create$VH.get(seg);
    }
    public static void thread_create$set( MemorySegment seg, MemoryAddress x) {
        _GThreadFunctions.thread_create$VH.set(seg, x);
    }
    public static MemoryAddress thread_create$get(MemorySegment seg, long index) {
        return (MemoryAddress)_GThreadFunctions.thread_create$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void thread_create$set(MemorySegment seg, long index, MemoryAddress x) {
        _GThreadFunctions.thread_create$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static thread_create thread_create (MemorySegment segment, ResourceScope scope) {
        return thread_create.ofAddress(thread_create$get(segment), scope);
    }
    static final FunctionDescriptor thread_yield$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle thread_yield$MH = RuntimeHelper.downcallHandle(
        _GThreadFunctions.thread_yield$FUNC, false
    );
    public interface thread_yield {

        void apply();
        static NativeSymbol allocate(thread_yield fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(thread_yield.class, fi, _GThreadFunctions.thread_yield$FUNC, "()V", scope);
        }
        static thread_yield ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("thread_yield::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return () -> {
                try {
                    _GThreadFunctions.thread_yield$MH.invokeExact(symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle thread_yield$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("thread_yield"));
    public static VarHandle thread_yield$VH() {
        return _GThreadFunctions.thread_yield$VH;
    }
    public static MemoryAddress thread_yield$get(MemorySegment seg) {
        return (MemoryAddress)_GThreadFunctions.thread_yield$VH.get(seg);
    }
    public static void thread_yield$set( MemorySegment seg, MemoryAddress x) {
        _GThreadFunctions.thread_yield$VH.set(seg, x);
    }
    public static MemoryAddress thread_yield$get(MemorySegment seg, long index) {
        return (MemoryAddress)_GThreadFunctions.thread_yield$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void thread_yield$set(MemorySegment seg, long index, MemoryAddress x) {
        _GThreadFunctions.thread_yield$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static thread_yield thread_yield (MemorySegment segment, ResourceScope scope) {
        return thread_yield.ofAddress(thread_yield$get(segment), scope);
    }
    static final FunctionDescriptor thread_join$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle thread_join$MH = RuntimeHelper.downcallHandle(
        _GThreadFunctions.thread_join$FUNC, false
    );
    public interface thread_join {

        void apply(MemoryAddress _x0);
        static NativeSymbol allocate(thread_join fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(thread_join.class, fi, _GThreadFunctions.thread_join$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)V", scope);
        }
        static thread_join ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("thread_join::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (MemoryAddress __x0) -> {
                try {
                    _GThreadFunctions.thread_join$MH.invokeExact(symbol, (Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle thread_join$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("thread_join"));
    public static VarHandle thread_join$VH() {
        return _GThreadFunctions.thread_join$VH;
    }
    public static MemoryAddress thread_join$get(MemorySegment seg) {
        return (MemoryAddress)_GThreadFunctions.thread_join$VH.get(seg);
    }
    public static void thread_join$set( MemorySegment seg, MemoryAddress x) {
        _GThreadFunctions.thread_join$VH.set(seg, x);
    }
    public static MemoryAddress thread_join$get(MemorySegment seg, long index) {
        return (MemoryAddress)_GThreadFunctions.thread_join$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void thread_join$set(MemorySegment seg, long index, MemoryAddress x) {
        _GThreadFunctions.thread_join$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static thread_join thread_join (MemorySegment segment, ResourceScope scope) {
        return thread_join.ofAddress(thread_join$get(segment), scope);
    }
    static final FunctionDescriptor thread_exit$FUNC = FunctionDescriptor.ofVoid();
    static final MethodHandle thread_exit$MH = RuntimeHelper.downcallHandle(
        _GThreadFunctions.thread_exit$FUNC, false
    );
    public interface thread_exit {

        void apply();
        static NativeSymbol allocate(thread_exit fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(thread_exit.class, fi, _GThreadFunctions.thread_exit$FUNC, "()V", scope);
        }
        static thread_exit ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("thread_exit::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return () -> {
                try {
                    _GThreadFunctions.thread_exit$MH.invokeExact(symbol);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle thread_exit$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("thread_exit"));
    public static VarHandle thread_exit$VH() {
        return _GThreadFunctions.thread_exit$VH;
    }
    public static MemoryAddress thread_exit$get(MemorySegment seg) {
        return (MemoryAddress)_GThreadFunctions.thread_exit$VH.get(seg);
    }
    public static void thread_exit$set( MemorySegment seg, MemoryAddress x) {
        _GThreadFunctions.thread_exit$VH.set(seg, x);
    }
    public static MemoryAddress thread_exit$get(MemorySegment seg, long index) {
        return (MemoryAddress)_GThreadFunctions.thread_exit$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void thread_exit$set(MemorySegment seg, long index, MemoryAddress x) {
        _GThreadFunctions.thread_exit$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static thread_exit thread_exit (MemorySegment segment, ResourceScope scope) {
        return thread_exit.ofAddress(thread_exit$get(segment), scope);
    }
    static final FunctionDescriptor thread_set_priority$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_INT$LAYOUT
    );
    static final MethodHandle thread_set_priority$MH = RuntimeHelper.downcallHandle(
        _GThreadFunctions.thread_set_priority$FUNC, false
    );
    public interface thread_set_priority {

        void apply(MemoryAddress _x0, int _x1);
        static NativeSymbol allocate(thread_set_priority fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(thread_set_priority.class, fi, _GThreadFunctions.thread_set_priority$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;I)V", scope);
        }
        static thread_set_priority ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("thread_set_priority::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (MemoryAddress __x0, int __x1) -> {
                try {
                    _GThreadFunctions.thread_set_priority$MH.invokeExact(symbol, (Addressable)__x0, __x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle thread_set_priority$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("thread_set_priority"));
    public static VarHandle thread_set_priority$VH() {
        return _GThreadFunctions.thread_set_priority$VH;
    }
    public static MemoryAddress thread_set_priority$get(MemorySegment seg) {
        return (MemoryAddress)_GThreadFunctions.thread_set_priority$VH.get(seg);
    }
    public static void thread_set_priority$set( MemorySegment seg, MemoryAddress x) {
        _GThreadFunctions.thread_set_priority$VH.set(seg, x);
    }
    public static MemoryAddress thread_set_priority$get(MemorySegment seg, long index) {
        return (MemoryAddress)_GThreadFunctions.thread_set_priority$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void thread_set_priority$set(MemorySegment seg, long index, MemoryAddress x) {
        _GThreadFunctions.thread_set_priority$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static thread_set_priority thread_set_priority (MemorySegment segment, ResourceScope scope) {
        return thread_set_priority.ofAddress(thread_set_priority$get(segment), scope);
    }
    static final FunctionDescriptor thread_self$FUNC = FunctionDescriptor.ofVoid(
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle thread_self$MH = RuntimeHelper.downcallHandle(
        _GThreadFunctions.thread_self$FUNC, false
    );
    public interface thread_self {

        void apply(MemoryAddress _x0);
        static NativeSymbol allocate(thread_self fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(thread_self.class, fi, _GThreadFunctions.thread_self$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;)V", scope);
        }
        static thread_self ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("thread_self::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (MemoryAddress __x0) -> {
                try {
                    _GThreadFunctions.thread_self$MH.invokeExact(symbol, (Addressable)__x0);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle thread_self$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("thread_self"));
    public static VarHandle thread_self$VH() {
        return _GThreadFunctions.thread_self$VH;
    }
    public static MemoryAddress thread_self$get(MemorySegment seg) {
        return (MemoryAddress)_GThreadFunctions.thread_self$VH.get(seg);
    }
    public static void thread_self$set( MemorySegment seg, MemoryAddress x) {
        _GThreadFunctions.thread_self$VH.set(seg, x);
    }
    public static MemoryAddress thread_self$get(MemorySegment seg, long index) {
        return (MemoryAddress)_GThreadFunctions.thread_self$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void thread_self$set(MemorySegment seg, long index, MemoryAddress x) {
        _GThreadFunctions.thread_self$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static thread_self thread_self (MemorySegment segment, ResourceScope scope) {
        return thread_self.ofAddress(thread_self$get(segment), scope);
    }
    static final FunctionDescriptor thread_equal$FUNC = FunctionDescriptor.of(Constants$root.C_INT$LAYOUT,
        Constants$root.C_POINTER$LAYOUT,
        Constants$root.C_POINTER$LAYOUT
    );
    static final MethodHandle thread_equal$MH = RuntimeHelper.downcallHandle(
        _GThreadFunctions.thread_equal$FUNC, false
    );
    public interface thread_equal {

        int apply(MemoryAddress _x0, MemoryAddress _x1);
        static NativeSymbol allocate(thread_equal fi, ResourceScope scope) {
            return RuntimeHelper.upcallStub(thread_equal.class, fi, _GThreadFunctions.thread_equal$FUNC, "(Ljdk/incubator/foreign/MemoryAddress;Ljdk/incubator/foreign/MemoryAddress;)I", scope);
        }
        static thread_equal ofAddress(MemoryAddress addr, ResourceScope scope) {
            NativeSymbol symbol = NativeSymbol.ofAddress("thread_equal::" + Long.toHexString(addr.toRawLongValue()), addr, scope);
return (MemoryAddress __x0, MemoryAddress __x1) -> {
                try {
                    return (int)_GThreadFunctions.thread_equal$MH.invokeExact(symbol, (Addressable)__x0, (Addressable)__x1);
                } catch (Throwable ex$) {
                    throw new AssertionError("should not reach here", ex$);
                }
            };
        }
    }

    static final VarHandle thread_equal$VH = $struct$LAYOUT.varHandle(PathElement.groupElement("thread_equal"));
    public static VarHandle thread_equal$VH() {
        return _GThreadFunctions.thread_equal$VH;
    }
    public static MemoryAddress thread_equal$get(MemorySegment seg) {
        return (MemoryAddress)_GThreadFunctions.thread_equal$VH.get(seg);
    }
    public static void thread_equal$set( MemorySegment seg, MemoryAddress x) {
        _GThreadFunctions.thread_equal$VH.set(seg, x);
    }
    public static MemoryAddress thread_equal$get(MemorySegment seg, long index) {
        return (MemoryAddress)_GThreadFunctions.thread_equal$VH.get(seg.asSlice(index*sizeof()));
    }
    public static void thread_equal$set(MemorySegment seg, long index, MemoryAddress x) {
        _GThreadFunctions.thread_equal$VH.set(seg.asSlice(index*sizeof()), x);
    }
    public static thread_equal thread_equal (MemorySegment segment, ResourceScope scope) {
        return thread_equal.ofAddress(thread_equal$get(segment), scope);
    }
    public static long sizeof() { return $LAYOUT().byteSize(); }
    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }
    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));
    }
    public static MemorySegment allocate(ResourceScope scope) { return allocate(SegmentAllocator.nativeAllocator(scope)); }
    public static MemorySegment allocateArray(int len, ResourceScope scope) {
        return allocateArray(len, SegmentAllocator.nativeAllocator(scope));
    }
    public static MemorySegment ofAddress(MemoryAddress addr, ResourceScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }
}


